from __future__ import annotations

import logging
from typing import Sequence, Tuple

import numpy as np
import torch
import SimpleITK as sitk
from torch import Tensor

logger = logging.getLogger(__name__)


def getBinEdges(parameterValues, **kwargs):
    binWidth = kwargs.get("binWidth", 25)
    binCount = kwargs.get("binCount")

    minimum = parameterValues.min()
    maximum = parameterValues.max()
    if binCount is not None:
        binEdges = torch.linspace(minimum, maximum, binCount + 1, device=parameterValues.device)
        binEdges[
            -1
        ] += 1  # Ensures that the maximum value is included in the topmost bin when using numpy.digitize
    else:
        # Start binning form the first value lesser than or equal to the minimum value and evenly dividable by binwidth
        lowBound = minimum - (minimum % binWidth)
        # Add + 2* binwidth to ensure the maximum value is included in the range generated by numpy.arange, and that values
        # equal to highbound are binned into a separate bin by numpy.histogram (This ensures ALL bins are half open, as
        # numpy.histogram treats the last bin as a closed interval. Moreover, this ensures consistency with numpy.digitize,
        # which will assign len(bins) + 1 to values equal to rightmost bin edge, treating all bins as half-open)
        highBound = maximum + 2 * binWidth

        binEdges = torch.arange(lowBound, highBound, binWidth, device=parameterValues.device)

        # if min(parameterValues) % binWidth = 0 and min(parameterValues) = max(parameterValues), binEdges will only contain
        # 1 value. If this is the case (flat region) ensure that numpy.histogram creates 1 bin (requires 2 edges). For
        # numpy.histogram, a binCount (1) would also suffice, however, this is not accepted by numpy.digitize, which also uses
        # binEdges calculated by this function.
        if len(binEdges) == 1:  # Flat region, ensure that there is 1 bin
            binEdges = [
                binEdges[0] - 0.5,
                binEdges[0] + 0.5,
            ]  # Simulates binEdges returned by numpy.histogram if bins = 1
        msg = f"Calculated {len(binEdges) - 1} bins for bin width {binWidth} with edges: {binEdges})"
        logger.debug(msg)

    return binEdges  # numpy.histogram(parameterValues, bins=binedges)


def binImage(parameterMatrix, parameterMatrixCoordinates=None, **kwargs):
    logger.debug("Discretizing gray levels inside ROI")

    discretizedParameterMatrix = torch.zeros(parameterMatrix.shape, device=parameterMatrix.device, dtype=torch.int32)
    if parameterMatrixCoordinates is None:
        binEdges = getBinEdges(parameterMatrix.flatten(), **kwargs)
        discretizedParameterMatrix = torch.bucketize(parameterMatrix, binEdges, right=True)  # np.digitize(..right=False) is equivalent to torch.bucketize(..., right=True)
    else:
        binEdges = getBinEdges(parameterMatrix[parameterMatrixCoordinates], **kwargs)
        discretizedParameterMatrix[parameterMatrixCoordinates] = torch.bucketize(
            parameterMatrix[parameterMatrixCoordinates], binEdges, right=True
        )

    return discretizedParameterMatrix, binEdges


def cropToTumorMask(
    imageNode: Tensor,
    maskNode: Tensor,
    boundingBox: Sequence[int],
    padDistance: int = 0,
) -> Tuple[Tensor, Tensor]:
    if imageNode.shape != maskNode.shape:
        raise ValueError(f"imageNode and maskNode must have same shape, got "
                         f"{imageNode.shape} vs {maskNode.shape}")

    Z, Y, X = imageNode.shape

    z_min, z_max, y_min, y_max, x_min, x_max = boundingBox

    z_min -= padDistance
    y_min -= padDistance
    x_min -= padDistance

    z_max += padDistance
    y_max += padDistance
    x_max += padDistance

    z_min = max(z_min, 0)
    y_min = max(y_min, 0)
    x_min = max(x_min, 0)

    z_max = min(z_max, Z - 1)
    y_max = min(y_max, Y - 1)
    x_max = min(x_max, X - 1)

    croppedImageNode = imageNode[z_min:z_max + 1,
                                 y_min:y_max + 1,
                                 x_min:x_max + 1]

    croppedMaskNode = maskNode[z_min:z_max + 1,
                               y_min:y_max + 1,
                               x_min:x_max + 1]

    return croppedImageNode, croppedMaskNode


def getOriginalImage(inputImage, _inputMask, **kwargs):
    logger.debug("Yielding original image")
    yield inputImage, "original", kwargs
