from __future__ import annotations

import numpy as np
import torch

from radiomics import base, cMatrices, deprecated

# from cmatrices import


class RadiomicsGLCM(base.RadiomicsFeaturesBase):
    def __init__(self, imageArray, maskArray, **kwargs):
        super().__init__(imageArray, maskArray, **kwargs)

        self.symmetricalGLCM = kwargs.get("symmetricalGLCM", True)
        self.weightingNorm = kwargs.get(
            "weightingNorm"
        )  # manhattan, euclidean, infinity

        self.P_glcm = None
        self.imageArray = self._applyBinning(self.imageArray)

    def _initCalculation(self, voxelCoordinates=None):
        self.P_glcm = self._calculateMatrix(voxelCoordinates)

        self._calculateCoefficients()

        self.logger.debug(
            "GLCM feature class initialized, calculated GLCM with shape %s",
            self.P_glcm.shape,
        )

    def _calculateMatrix(self, voxelCoordinates=None):
        r"""
        Compute GLCMs for the input image for every direction in 3D.
        Calculated GLCMs are placed in array P_glcm with shape (i/j, a)
        i/j = total gray-level bins for image array,
        a = directions in 3D (generated by imageoperations.generateAngles)
        """
        self.logger.debug("Calculating GLCM matrix in C")

        Ng = self.coefficients["Ng"]

        matrix_args = [
            self.imageArray,
            self.maskArray,
            torch.tensor(self.settings.get("distances", [1]), device=self.device),
            Ng,
            self.settings.get("force2D", False),
            self.settings.get("force2Ddimension", 0),
        ]
        if self.voxelBased:
            matrix_args += [self.settings.get("kernelRadius", 1), voxelCoordinates]

        P_glcm, angles = cMatrices.calculate_glcm(*matrix_args)

        self.logger.debug("Process calculated matrix")

        # Delete rows and columns that specify gray levels not present in the ROI
        GrayLevels = self.coefficients["grayLevels"]  # Gray values present in ROI
        P_glcm = P_glcm[:, GrayLevels - 1, :, :]
        P_glcm = P_glcm[:, :, GrayLevels - 1, :]

        # Optionally make GLCMs symmetrical for each angle
        if self.symmetricalGLCM:
            self.logger.debug("Create symmetrical matrix")
            P_glcm = P_glcm + np.transpose(P_glcm, (0, 2, 1, 3))

        # Optionally apply a weighting factor
        if self.weightingNorm is not None:
            self.logger.debug("Applying weighting (%s)", self.weightingNorm)
            pixelSpacing = self.inputImage.GetSpacing()[::-1]
            weights = np.empty(len(angles))
            for a_idx, a in enumerate(angles):
                if self.weightingNorm == "infinity":
                    weights[a_idx] = np.exp(-max(np.abs(a) * pixelSpacing) ** 2)
                elif self.weightingNorm == "euclidean":
                    weights[a_idx] = np.exp(
                        -np.sum((np.abs(a) * pixelSpacing) ** 2)
                    )  # sqrt ^ 2 = 1
                elif self.weightingNorm == "manhattan":
                    weights[a_idx] = np.exp(-np.sum(np.abs(a) * pixelSpacing) ** 2)
                elif self.weightingNorm == "no_weighting":
                    weights[a_idx] = 1
                else:
                    self.logger.warning(
                        'weigthing norm "%s" is unknown, W is set to 1',
                        self.weightingNorm,
                    )
                    weights[a_idx] = 1

            P_glcm = np.sum(P_glcm * weights[None, None, None, :], 3, keepdims=True)

        sumP_glcm = np.sum(P_glcm, (1, 2))

        # Delete empty angles if no weighting is applied
        if P_glcm.shape[3] > 1:
            emptyAngles = np.where(np.sum(sumP_glcm, 0) == 0)
            if len(emptyAngles[0]) > 0:  # One or more angles are 'empty'
                self.logger.debug(
                    "Deleting %d empty angles:\n%s",
                    len(emptyAngles[0]),
                    angles[emptyAngles],
                )
                P_glcm = np.delete(P_glcm, emptyAngles, 3)
                sumP_glcm = np.delete(sumP_glcm, emptyAngles, 1)
            else:
                self.logger.debug("No empty angles")

        # Mark empty angles with NaN, allowing them to be ignored in feature calculation
        sumP_glcm[sumP_glcm == 0] = np.nan
        # Normalize each glcm
        P_glcm /= sumP_glcm[:, None, None, :]

        return P_glcm

    # check if ivector and jvector can be replaced
    def _calculateCoefficients(self):
        r"""
        Calculate and fill in the coefficients dict.
        """
        self.logger.debug("Calculating GLCM coefficients")

        Ng = self.coefficients["Ng"]
        eps = torch.finfo(torch.float32).eps.to(self.device)

        NgVector = self.coefficients["grayLevels"].float()
        # shape = (Ng, Ng)
        i, j = torch.meshgrid(NgVector, NgVector, indexing="ij", sparse=True)
        # shape = (2*Ng-1)
        kValuesSum = torch.arange(2, (Ng * 2) + 1, dtype=torch.float, device=self.device)
        # shape = (Ng-1)
        kValuesDiff = torch.arange(0, Ng, dtype=torch.float, device=self.device)

        # marginal row probabilities #shape = (Nv, Ng, 1, angles)
        px = self.P_glcm.sum(2, keepdims=True)
        # marginal column probabilities #shape = (Nv, 1, Ng, angles)
        py = self.P_glcm.sum(1, keepdims=True)

        # shape = (Nv, 1, 1, angles)
        ux = torch.sum(i[None, :, :, None] * self.P_glcm, dim=(1, 2), keepdims=True)
        uy = torch.sum(j[None, :, :, None] * self.P_glcm, dim=(1, 2), keepdims=True)

        # shape = (Nv, 2*Ng-1, angles)
        pxAddy = torch.tensor(
            [torch.sum(self.P_glcm[:, i + j == k, :], dim=1) for k in kValuesSum]
        ).transpose((1, 0, 2))
        # shape = (Nv, Ng, angles)
        pxSuby = torch.tensor(
            [torch.sum(self.P_glcm[:, torch.abs(i - j) == k, :], dim=1) for k in kValuesDiff]
        ).transpose((1, 0, 2))

        # shape = (Nv, angles)
        HXY = (-1) * torch.sum((self.P_glcm * torch.log2(self.P_glcm + eps)), dim=(1, 2))
        
        self.coefficients["eps"] = eps
        self.coefficients["i"] = i
        self.coefficients["j"] = j
        self.coefficients["kValuesSum"] = kValuesSum
        self.coefficients["kValuesDiff"] = kValuesDiff
        self.coefficients["px"] = px
        self.coefficients["py"] = py
        self.coefficients["ux"] = ux
        self.coefficients["uy"] = uy
        self.coefficients["pxAddy"] = pxAddy
        self.coefficients["pxSuby"] = pxSuby
        self.coefficients["HXY"] = HXY

    def getAutocorrelationFeatureValue(self):
        r"""
        **1. Autocorrelation**

        .. math::
          \textit{autocorrelation} = \displaystyle\sum^{N_g}_{i=1}\displaystyle\sum^{N_g}_{j=1}{p(i,j)ij}

        Autocorrelation is a measure of the magnitude of the fineness and coarseness of texture.
        """
        i = self.coefficients["i"]
        j = self.coefficients["j"]
        ac = torch.sum(self.P_glcm * (i * j)[None, :, :, None], (1, 2))
        return torch.nanmean(ac, dim=(1, 2))

    def getJointAverageFeatureValue(self):
        if not self.symmetricalGLCM:
            self.logger.warning(
                "The formula for GLCM - Joint Average assumes that the GLCM is symmetrical, but this is not the case."
            )
        return self.coefficients["ux"].mean(dim=(1, 2, 3))

    def getClusterProminenceFeatureValue(self):
        i = self.coefficients["i"]
        j = self.coefficients["j"]
        ux = self.coefficients["ux"]
        uy = self.coefficients["uy"]
        cp = torch.sum(
            (self.P_glcm * (((i + j)[None, :, :, None] - ux - uy) ** 4)), dim=(1, 2)
        )
        return torch.nanmean(cp, dim=1)

    def getClusterShadeFeatureValue(self):
        r"""
        **4. Cluster Shade**

        .. math::
          \textit{cluster shade} = \displaystyle\sum^{N_g}_{i=1}\displaystyle\sum^{N_g}_{j=1}
          {\big(i+j-\mu_x-\mu_y\big)^3p(i,j)}

        Cluster Shade is a measure of the skewness and uniformity of the GLCM.
        A higher cluster shade implies greater asymmetry about the mean.
        """
        i = self.coefficients["i"]
        j = self.coefficients["j"]
        ux = self.coefficients["ux"]
        uy = self.coefficients["uy"]
        cs = torch.sum(
            (self.P_glcm * (((i + j)[None, :, :, None] - ux - uy) ** 3)), dim=(1, 2)
        )
        return torch.nanmean(cs, dim=1)

    def getClusterTendencyFeatureValue(self):
        r"""
        **5. Cluster Tendency**

        .. math::
          \textit{cluster tendency} = \displaystyle\sum^{N_g}_{i=1}\displaystyle\sum^{N_g}_{j=1}
          {\big(i+j-\mu_x-\mu_y\big)^2p(i,j)}

        Cluster Tendency is a measure of groupings of voxels with similar gray-level values.
        """
        i = self.coefficients["i"]
        j = self.coefficients["j"]
        ux = self.coefficients["ux"]
        uy = self.coefficients["uy"]
        ct = torch.sum(
            (self.P_glcm * (((i + j)[None, :, :, None] - ux - uy) ** 2)), dim=(1, 2)
        )
        return torch.nanmean(ct, dim=1)

    def getContrastFeatureValue(self):
        r"""
        **6. Contrast**

        .. math::
          \textit{contrast} = \displaystyle\sum^{N_g}_{i=1}\displaystyle\sum^{N_g}_{j=1}{(i-j)^2p(i,j)}

        Contrast is a measure of the local intensity variation, favoring values away from the diagonal :math:`(i = j)`. A
        larger value correlates with a greater disparity in intensity values among neighboring voxels.
        """
        i = self.coefficients["i"]
        j = self.coefficients["j"]
        cont = torch.sum((self.P_glcm * ((torch.abs(i - j))[None, :, :, None] ** 2)), dim=(1, 2))
        return torch.nanmean(cont, dim=1)

    def getCorrelationFeatureValue(self):
        eps = self.coefficients["eps"]
        i = self.coefficients["i"]
        j = self.coefficients["j"]
        ux = self.coefficients["ux"]
        uy = self.coefficients["uy"]

        # shape = (Nv, 1, 1, angles)
        sigx = (
            torch.sum(
                self.P_glcm * ((i[None, :, :, None] - ux) ** 2), dim=(1, 2), keepdims=True
            )
            ** 0.5
        )
        # shape = (Nv, 1, 1, angles)
        sigy = (
            torch.sum(
                self.P_glcm * ((j[None, :, :, None] - uy) ** 2), dim=(1, 2), keepdims=True
            )
            ** 0.5
        )

        corm = torch.sum(
            self.P_glcm * (i[None, :, :, None] - ux) * (j[None, :, :, None] - uy),
            dim=(1, 2),
            keepdims=True,
        )
        corr = corm / (sigx * sigy + eps)
        corr[sigx * sigy == 0] = 1  # Set elements that would be divided by 0 to 1.
        return torch.nanmean(corr, dim=(1, 2, 3))

    def getDifferenceAverageFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        diffavg = torch.sum((kValuesDiff[None, :, None] * pxSuby), dim=1)
        return torch.nanmean(diffavg, dim=1)

    def getDifferenceEntropyFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        eps = self.coefficients["eps"]
        difent = (-1) * torch.sum((pxSuby * torch.log2(pxSuby + eps)), dim=1)
        return torch.nanmean(difent, dim=1)

    def getDifferenceVarianceFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        diffavg = torch.sum((kValuesDiff[None, :, None] * pxSuby), dim=1, keepdims=True)
        diffvar = torch.sum((pxSuby * ((kValuesDiff[None, :, None] - diffavg) ** 2)), dim=1)
        return torch.nanmean(diffvar, dim=1)

    @deprecated
    def getDissimilarityFeatureValue(self):
        msg = (
            "GLCM - Dissimilarity is mathematically equal to GLCM - Difference Average, "
            "see http://pyradiomics.readthedocs.io/en/latest/removedfeatures.html for more details"
        )
        raise DeprecationWarning(msg)

    def getJointEnergyFeatureValue(self):
        ene = torch.sum((self.P_glcm**2), dim=(1, 2))
        return torch.nanmean(ene, dim=1)

    def getJointEntropyFeatureValue(self):
        ent = self.coefficients["HXY"]
        return torch.nanmean(ent, dim=1)

    @deprecated
    def getHomogeneity1FeatureValue(self):
        msg = (
            "GLCM - Homogeneity 1 is mathematically equal to GLCM - Inverse Difference, "
            'see documentation of the GLCM feature class (section "Radiomic Features") for more details'
        )
        raise DeprecationWarning(msg)

    @deprecated
    def getHomogeneity2FeatureValue(self):
        msg = (
            "GLCM - Homogeneity 2 is mathematically equal to GLCM - Inverse Difference Moment, "
            'see documentation of the GLCM feature class (section "Radiomic Features") for more details'
        )
        raise DeprecationWarning(msg)

    def getImc1FeatureValue(self):
        HXY = self.coefficients["HXY"]

        eps = self.coefficients["eps"]
        px = self.coefficients["px"]
        py = self.coefficients["py"]

        # entropy of px # shape = (Nv, angles)
        HX = (-1) * torch.sum((px * torch.log2(px + eps)), dim=(1, 2))
        # entropy of py # shape = (Nv, angles)
        HY = (-1) * torch.sum((py * torch.log2(py + eps)), dim=(1, 2))
        # shape = (Nv, angles)
        HXY1 = (-1) * torch.sum((self.P_glcm * torch.log2(px * py + eps)), dim=(1, 2))
        div = torch.fmax(HX, HY)

        imc1 = HXY - HXY1
        imc1[div != 0] /= div[div != 0]
        imc1[div == 0] = 0  # Set elements that would be divided by 0 to 0

        return torch.nanmean(imc1, dim=1)

    def getImc2FeatureValue(self):
        HXY = self.coefficients["HXY"]

        eps = self.coefficients["eps"]
        px = self.coefficients["px"]
        py = self.coefficients["py"]

        # shape = (Nv, angles)
        HXY2 = (-1) * torch.sum(((px * py) * torch.log2(px * py + eps)), dim=(1, 2))

        imc2 = torch.sqrt(1 - torch.exp(-2 * (HXY2 - HXY)))
        imc2[HXY2 == HXY] = 0

        return torch.nanmean(imc2, dim=1)

    def getIdmFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        idm = torch.sum(pxSuby / (1 + (kValuesDiff[None, :, None] ** 2)), dim=1)
        return torch.nanmean(idm, dim=1)

    def getMCCFeatureValue(self):
        px = self.coefficients["px"]
        py = self.coefficients["py"]
        eps = self.coefficients["eps"]

        # Calculate Q (shape (i, i, d)). To prevent division by 0, add epsilon (such a division can occur when in a ROI
        # along a certain angle, voxels with gray level i do not have neighbors
        Q = (
            self.P_glcm[:, :, None, 0, :] * self.P_glcm[:, None, :, 0, :]
        ) / (  # slice: v, i, j, k, d
            px[:, :, None, 0, :] * py[:, None, :, 0, :] + eps
        )  # sum over k (4th axis --> index 3)

        for gl in range(1, self.P_glcm.shape[1]):
            Q += (
                self.P_glcm[:, :, None, gl, :] * self.P_glcm[:, None, :, gl, :]
            ) / (  # slice: v, i, j, k, d
                px[:, :, None, 0, :] * py[:, None, :, gl, :] + eps
            )  # sum over k (4th axis --> index 3)

        # calculation of eigenvalues if performed on last 2 dimensions, therefore, move the angles dimension (d) forward
        Q_eigenValue = torch.linalg.eigvals(Q.permute(0, 3, 1, 2))
        Q_eigValue, _ = torch.sort(Q_eigenValue, dim=-1)  # 最后一维升序  # sorts along last axis --> eigenvalues, low to high

        if Q_eigenValue.shape[2] < 2:
            return 1  # flat region

        MCC = torch.sqrt(Q_eigValue[:, :, -2])  # 2nd highest eigenvalue

        return torch.nanmean(MCC, dim=1).real

    def getIdmnFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        Ng = self.coefficients["Ng"]
        idmn = torch.sum(pxSuby / (1 + ((kValuesDiff[None, :, None] ** 2) / (Ng**2))), dim=1)
        return torch.nanmean(idmn, dim=1)

    def getIdFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        invDiff = torch.sum(pxSuby / (1 + kValuesDiff[None, :, None]), dim=1)
        return torch.nanmean(invDiff, dim=1)

    def getIdnFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        Ng = self.coefficients["Ng"]
        idn = torch.sum(pxSuby / (1 + (kValuesDiff[None, :, None] / Ng)), dim=1)
        return torch.nanmean(idn, dim=1)

    def getInverseVarianceFeatureValue(self):
        pxSuby = self.coefficients["pxSuby"]
        kValuesDiff = self.coefficients["kValuesDiff"]
        inv = torch.sum(
            pxSuby[:, 1:, :] / kValuesDiff[None, 1:, None] ** 2, dim=1
        )  # Skip k = 0 (division by 0)
        return torch.nanmean(inv, dim=1)

    def getMaximumProbabilityFeatureValue(self):
        maxprob = torch.amax(self.P_glcm, dim=(1, 2))
        return torch.nanmean(maxprob, dim=1)

    def getSumAverageFeatureValue(self):
        # warn the user if the GLCM is symmetrical and this feature is calculated (as it is then linearly correlated to Joint Average)
        if self.symmetricalGLCM:
            self.logger.warning(
                "GLCM is symmetrical, therefore Sum Average = 2 * Joint Average, only 1 needs to be calculated"
            )

        pxAddy = self.coefficients["pxAddy"]
        kValuesSum = self.coefficients["kValuesSum"]
        sumavg = torch.sum((kValuesSum[None, :, None] * pxAddy), dim=1)
        return torch.nanmean(sumavg, dim=1)

    @deprecated
    def getSumVarianceFeatureValue(self):
        msg = (
            "GLCM - Sum Variance is mathematically equal to GLCM - Cluster Tendency, "
            "see http://pyradiomics.readthedocs.io/en/latest/removedfeatures.html for more details"
        )
        raise DeprecationWarning(msg)

    def getSumEntropyFeatureValue(self):
        pxAddy = self.coefficients["pxAddy"]
        eps = self.coefficients["eps"]
        sumentr = (-1) * torch.sum(pxAddy * torch.log2(pxAddy + eps), dim=1)
        return torch.nanmean(sumentr, dim=1)

    def getSumSquaresFeatureValue(self):
        if not self.symmetricalGLCM:
            self.logger.warning(
                "The formula for GLCM - Sum of Squares assumes that the GLCM is symmetrical, but this is not the case."
            )
        i = self.coefficients["i"]
        ux = self.coefficients["ux"]
        # Also known as Variance
        ss = torch.sum(self.P_glcm * ((i[None, :, :, None] - ux) ** 2), dim=(1, 2))
        return torch.nanmean(ss, dim=1)
